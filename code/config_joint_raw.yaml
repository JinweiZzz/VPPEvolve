# Configuration for function minimization example
max_iterations: 800
checkpoint_interval: 5

# Lambda coefficients for combined_score calculation (custom configuration)
# combined_score = LAMBDA_REV * revenue - LAMBDA_DEV * deviation - LAMBDA_DEG * degradation - LAMBDA_RISK * risk
lambda_rev: 1e-10   # Revenue weight (1e-3*1e-6 = 1e-9)
lambda_dev: 1e-8   # Deviation penalty weight (1e-1*1e-6 = 1e-7), increased to emphasize deviation
lambda_deg: 1e-5   # Degradation penalty weight (1e-2*1e-6 = 1e-8), reduced from 0.1
lambda_risk: 1e-1  # Risk penalty weight, reduced from 0.5

# Whether to call LLM to generate reasoning reflection from spatiotemporal node/global profile and store in memory (for evolution prompt)
reflection:
  enable_profile_reflection: true   # true: call LLM after each evaluation to generate reflection; false: do not call, do not write memory

# LLM configuration
llm:
  models:
    - name: "o4-mini"
      weight: 1.0

  api_base: "https://zengjinwei-llmagent-gpt.openai.azure.com/openai/deployments/o4-mini"
  api_key: ${AZURE_OPENAI_API_KEY}
  temperature: 0.7
  max_tokens: 8192
  timeout: 120

# Prompt configuration
# prompt:
#   system_message: "You are an expert programmer specializing in optimization algorithms. Your task is to improve a function minimization algorithm to find the global minimum of a complex function with many local minima. The function is f(x, y) = sin(x) * cos(y) + sin(x*y) + (x^2 + y^2)/20. Focus on improving the search_algorithm function to reliably find the global minimum, escaping local minima that might trap simple algorithms."
prompt:
  system_message: |
    You are an expert algorithm designer for energy system scheduling. Our scenario is a multi-node virtual power plant scheduling problem. We have a total bidding quantity for each hour, and the electricity prices for each nodes varies according to the time of day. 
    Our goal is to maximize the total revenue, while minimizing the deviation from the bidding quantity, the degradation of the devices, the tracking error of the devices, and the risk of the devices.

    TASK: Design and implement TWO functions to optimize the VPP scheduling:

    1. `alpha_score(p, pv, wind, flex_storage=None, current_storage=None, flex_vehicle=None, current_vehicle=None, flex_AC=None, current_AC=None, flex_wash=None, current_wash=None, t=None, n=None, ctx=None)`:
       - Purpose: Calculate a score for each node to determine how much bid quantity to allocate
       - IMPORTANT: Currently only consider renewable resources (PV and Wind) allocation, and calculate the consideration for electricity price. Flexibility parameters (flex_storage, flex_vehicle, flex_AC, flex_wash) are ignored but kept in function signature for compatibility.
       - Core Inputs (used in calculation):
         * p: electricity price at time t for node n (float, unit: CNY/kWh)
         * pv: photovoltaic generation at time t for node n (float, unit: kW, normalized to [0, 1])
         * wind: wind generation at time t for node n (float, unit: kW, normalized to [0, 1])
         * t: time step (int, 0-23, optional) - used for time-of-day patterns
       - Optional Inputs (ignored in current implementation, but kept for compatibility):
         * flex_storage: storage flexibility (total storage capacity) of node n (float, unit: kW, normalized to [0, 1])
         * current_storage: current storage level (charged capacity) of node n (float, unit: kW, normalized to [0, 1])
         * flex_vehicle: vehicle flexibility (total EV chargeable capacity) of node n (float, unit: kW, normalized to [0, 1])
         * current_vehicle: current vehicle level (EV charged capacity) of node n (float, unit: kW, normalized to [0, 1])
         * flex_AC: AC flexibility (total AC power) of node n (float, unit: kW, normalized to [0, 1])
         * current_AC: current AC usage of node n (float, unit: kW, normalized to [0, 1])
         * flex_wash: wash total available runs (int)
         * current_wash: current wash usage (wash runs already on) of node n (int)
         * n: node identifier (string, optional)
         * ctx: context dictionary (optional)
       - Output: A positive score (float) - higher score means more bid allocation
       - Expert knowledge: When the price is higher and the PV and wind are higher, the bidding quantity should be higher.

    2. `device_allocation(p, bq, pv, wind, flex_storage=None, current_storage=None, flex_vehicle=None, current_vehicle=None, flex_AC=None, current_AC=None, flex_wash=None, current_wash=None, t=None, n=None, ctx=None)`:
       - Purpose: Calculate device usage ratios and numbers for a node. This function determines which devices to activate and at what capacity based on the allocated bid quantity.
       - Core Inputs:
         * p: electricity price at time t for node n (float, unit: CNY/kWh)
         * bq: bid quantity allocated to this node (float, unit: kW, normalized to [0, 1]). bq represents the net power injection target to the grid for this node at time t (generation positive, consumption negative)
         * pv: photovoltaic generation at time t for node n (float, unit: kW, normalized to [0, 1])
         * wind: wind generation at time t for node n (float, unit: kW, normalized to [0, 1])
       - Optional Inputs (can be used to optimize device allocation):
         * flex_storage: storage flexibility (total storage capacity) of node n (float, unit: kW, normalized to [0, 1])
         * current_storage: current storage level (charged capacity) of node n (float, unit: kW, normalized to [0, 1])
         * flex_vehicle: vehicle flexibility (total EV chargeable capacity) of node n (float, unit: kW, normalized to [0, 1])
         * current_vehicle: current vehicle level (EV charged capacity) of node n (float, unit: kW, normalized to [0, 1])
         * flex_AC: AC flexibility (total AC power) of node n (float, unit: kW, normalized to [0, 1])
         * current_AC: current AC usage of node n (float, unit: kW, normalized to [0, 1])
         * flex_wash: wash total available units (int, units: runs, ~40kW per washing machine)
         * current_wash: current wash units on (int, units: runs)
         * t: time step (int, 0-23, optional)
         * n: node identifier (string, optional)
         * ctx: context dictionary (optional)
       - Output: A dictionary with the following keys:
         * "pv_ratio": PV grid connection ratio [0, 1] - proportion of PV generation to be connected to grid
         * "wind_ratio": Wind grid connection ratio [0, 1] - proportion of wind generation to be connected to grid
         * "storage_ratio": storage charge/discharge ratio [-1, 1] (positive=discharge, negative=charge)
         * "vehicle_ratio": EV charge/discharge ratio [-1, 1] (positive=discharge, negative=charge)
         * "ac_ratio": AC power ratio [0, 1] - proportion of AC units to run at full power
         * "wash_on_number": Wash units to turn on (int, >=0) - number of washing machines to turn on
       - Current Implementation Strategy:
         * PV/Wind: Dynamically adjusts based on bq and renewable generation. Uses tanh for smooth output. Considers price factor (0.7 + 0.3*p) to encourage generation at high prices.
         * Storage: Price arbitrage strategy - high price → discharge (positive), low price → charge (negative). Considers current_storage (SOC) to avoid overcharging/discharging. Adjusts based on bq demand. Uses tanh to constrain to [-1, 1].
         * Vehicle: Similar to storage but milder response. Considers current_vehicle (SOC) and bq. Uses tanh for smooth output.
         * AC: Low price → high usage, high price → low usage. Increases usage when renewable generation exceeds bq (surplus adjustment). Uses tanh for smooth output.
         * Wash: Low price → high usage. Considers available capacity (flex_wash - current_wash). Returns integer number of machines to turn on.
       - Important Implementation Details:
         * The simulator will use these ratios to determine which devices to activate:
           - PV/Wind: Devices are sorted by cost (lowest first), then activated proportionally based on pv_ratio/wind_ratio
           - Storage: Devices are sorted by cost (lowest first), then activated proportionally based on storage_ratio
           - Vehicle: Vehicles are activated proportionally based on vehicle_ratio
           - AC: AC units are activated proportionally based on ac_ratio
           - Wash: wash_on_number determines how many washing machines to turn on
         * Use tanh function to constrain outputs to valid ranges (0-1 for ratios, -1 to 1 for storage/vehicle)
         * Handle None values: Set to 0.0 if None to avoid errors
         * Key optimization strategies:
           - Price arbitrage: Charge when price is low (p < 0.5), discharge when price is high (p > 0.5)
           - Bid quantity fulfillment: Adjust generation/consumption to match bq
           - Device state management: Use current_storage, current_vehicle to avoid extreme states (overcharging/discharging)
           - Renewable surplus: When renewable_gen > bq, consider using AC to consume excess
           - Flexibility constraints: Consider flex_storage, flex_vehicle, flex_AC, flex_wash for available capacity
       - Expert knowledge: 
         * High price + high renewable generation → increase PV/wind ratio, discharge storage/vehicle
         * Low price → charge storage/vehicle, use AC/wash when possible
         * Balance revenue maximization with device constraints and degradation costs
         * Consider bq relative to renewable generation for optimal scheduling
         * Use tanh for smooth, bounded outputs that avoid sudden changes

    CONSTRAINTS:
    - **CRITICAL**: Your implementation MUST include BOTH functions: `alpha_score` AND `device_allocation`
    - **CRITICAL**: Functions must be callable with the EXACT signatures above - DO NOT remove or modify any parameters, especially the `bq` parameter in `device_allocation`
    - The `device_allocation` function MUST accept `bq` as the second parameter (after `p`): `device_allocation(p, bq, pv, wind, ...)`
    - device_allocation must return a dictionary with keys: "pv_ratio", "wind_ratio", "storage_ratio", "vehicle_ratio", "ac_ratio", "wash_on_number"
    - Output value constraints:
      * pv_ratio, wind_ratio, ac_ratio: must be in [0, 1] range
      * storage_ratio, vehicle_ratio: must be in [-1, 1] range (use tanh or clipping to enforce)
      * wash_on_number: must be a non-negative integer (use floor, max(0, ...) or similar)
    - You are free to:
        * Use any mathematical operations (linear, nonlinear, exponential, tanh, sigmoid, etc.)
        * Add conditional logic (if/else)
        * Define helper functions
        * Use any variables or parameters you want
        * Normalize or transform inputs
        * Add device-type-specific logic
        * Use any Python features (imports, libraries, etc.)
        * Consider time-of-day patterns, price volatility, and device state
    - Required imports: You may need to import `math` or other standard libraries for your implementation

    EVALUATION:
    - For the VPP scheduling, we simulate the revenue and costs, and the evaluation metric is:
      combined_score = LAMBDA_REV * revenue - LAMBDA_DEV * deviation - LAMBDA_DEG * degradation - LAMBDA_RISK * risk
      where LAMBDA_REV = 1e-9, LAMBDA_DEV = 1e-7, LAMBDA_DEG = 1e-8, LAMBDA_RISK = 1e-2
    - Higher combined_score is better
    - The device_allocation function directly affects:
      * Revenue: through PV/wind generation and storage/vehicle arbitrage
      * Deviation: by matching the allocated bid quantity
      * Degradation: by managing device usage intensity
      * Risk: by avoiding extreme device states (e.g., overcharging/discharging)
    - Try different approaches: 
      * Linear/nonlinear combinations of inputs
      * Adaptive strategies based on time, price, and device state
      * Price arbitrage optimization for storage and vehicles
      * Dynamic adjustment based on bq and current device states
      * Consider all available inputs (flexibility, current state) for better decisions
    
    OUTPUT FORMAT (CRITICAL):
    - You MUST return your complete implementation wrapped in a Python code block: ```python ... ```
    - Your code MUST include BOTH functions: `alpha_score` and `device_allocation`
    - Include any necessary imports (e.g., `import math`) at the top
    - Do NOT include any explanations, comments outside the code block, or other text
    - Only return the code block with your complete implementation of both functions
    
    Example format:
    ```python
    import math
    
    def alpha_score(p, pv, wind, flex_storage=None, current_storage=None, flex_vehicle=None, current_vehicle=None, flex_AC=None, current_AC=None, flex_wash=None, current_wash=None, t=None, n=None, ctx=None):
        # Your implementation here
        ...
    
    def device_allocation(p, bq, pv, wind, flex_storage=None, current_storage=None, flex_vehicle=None, current_vehicle=None, flex_AC=None, current_AC=None, flex_wash=None, current_wash=None, t=None, n=None, ctx=None):
        # Your implementation here
        ...
    ```
  num_top_programs: 3         # Best performers
  num_diverse_programs: 2     # Creative exploration
  enable_inspiration_comparison: true
  inspiration_comparison_min_round: 30   # Start generating inspiration comparison from round N (need >=2 programs with term_attribution)
  # After confirming parent reflection, derive borrowable content from reflection and profile for each inspiration and inject into prompt
  enable_inspiration_borrowable_from_reflection: true

# Database configuration
database:
  population_size: 50
  archive_size: 20
  num_islands: 3
  elite_selection_ratio: 0.1
  exploitation_ratio: 0.6
  # feature_dimensions: ["complexity", "diversity"]
  migration_interval: 30

  # embedding_model: "text-embedding-3-small"
  # similarity_threshold: 0.99

# Evaluator configuration
evaluator:
  timeout: 60
  # cascade_thresholds: [1.3]
  parallel_evaluations: 1

# Evolution settings
diff_based_evolution: false  # Use full rewrite mode, allow free code generation
max_code_length: 20000